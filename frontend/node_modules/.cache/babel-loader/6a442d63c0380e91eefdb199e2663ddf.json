{"ast":null,"code":"var _ = require('./utils');\n\nvar ajax = require('./ajax');\n\nvar VERSION = require('./version');\n\nmodule.exports = function (o) {\n  var defaults, sorter;\n  defaults = {\n    initialize: true,\n    identify: _.stringify,\n    datumTokenizer: null,\n    queryTokenizer: null,\n    sufficient: 5,\n    sorter: null,\n    local: [],\n    prefetch: null,\n    remote: null\n  };\n  o = _.mixin(defaults, o || {}); // throw error if required options are not set\n\n  !o.datumTokenizer && _.error('datumTokenizer is required');\n  !o.queryTokenizer && _.error('queryTokenizer is required');\n  sorter = o.sorter;\n  o.sorter = sorter ? function (x) {\n    return x.sort(sorter);\n  } : _.identity;\n  o.local = _.isFunction(o.local) ? o.local() : o.local;\n  o.prefetch = parsePrefetch(o.prefetch);\n  o.remote = parseRemote(o.remote);\n  return o;\n};\n\nfunction parsePrefetch(o) {\n  var defaults;\n\n  if (!o) {\n    return null;\n  }\n\n  defaults = {\n    url: null,\n    ttl: 24 * 60 * 60 * 1000,\n    // 1 day\n    cache: true,\n    cacheKey: null,\n    thumbprint: '',\n    prepare: _.identity,\n    transform: _.identity,\n    transport: null\n  }; // support basic (url) and advanced configuration\n\n  o = _.isString(o) ? {\n    url: o\n  } : o;\n  o = _.mixin(defaults, o); // throw error if required options are not set\n\n  !o.url && _.error('prefetch requires url to be set'); // DEPRECATED: filter will be dropped in v1\n\n  o.transform = o.filter || o.transform;\n  o.cacheKey = o.cacheKey || o.url;\n  o.thumbprint = VERSION + o.thumbprint;\n  o.transport = o.transport ? callbackToDeferred(o.transport) : ajax;\n  return o;\n}\n\nfunction parseRemote(o) {\n  var defaults;\n\n  if (!o) {\n    return;\n  }\n\n  defaults = {\n    url: null,\n    cache: true,\n    // leave undocumented\n    prepare: null,\n    replace: null,\n    wildcard: null,\n    limiter: null,\n    rateLimitBy: 'debounce',\n    rateLimitWait: 300,\n    transform: _.identity,\n    transport: null\n  }; // support basic (url) and advanced configuration\n\n  o = _.isString(o) ? {\n    url: o\n  } : o;\n  o = _.mixin(defaults, o); // throw error if required options are not set\n\n  !o.url && _.error('remote requires url to be set'); // DEPRECATED: filter will be dropped in v1\n\n  o.transform = o.filter || o.transform;\n  o.prepare = toRemotePrepare(o);\n  o.limiter = toLimiter(o);\n  o.transport = o.transport ? callbackToDeferred(o.transport) : ajax;\n  delete o.replace;\n  delete o.wildcard;\n  delete o.rateLimitBy;\n  delete o.rateLimitWait;\n  return o;\n}\n\nfunction toRemotePrepare(o) {\n  var prepare, replace, wildcard;\n  prepare = o.prepare;\n  replace = o.replace;\n  wildcard = o.wildcard;\n\n  if (prepare) {\n    return prepare;\n  }\n\n  if (replace) {\n    prepare = prepareByReplace;\n  } else if (o.wildcard) {\n    prepare = prepareByWildcard;\n  } else {\n    prepare = idenityPrepare;\n  }\n\n  return prepare;\n\n  function prepareByReplace(query, settings) {\n    settings.url = replace(settings.url, query);\n    return settings;\n  }\n\n  function prepareByWildcard(query, settings) {\n    settings.url = settings.url.replace(wildcard, encodeURIComponent(query));\n    return settings;\n  }\n\n  function idenityPrepare(query, settings) {\n    return settings;\n  }\n}\n\nfunction toLimiter(o) {\n  var limiter, method, wait;\n  limiter = o.limiter;\n  method = o.rateLimitBy;\n  wait = o.rateLimitWait;\n\n  if (!limiter) {\n    limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);\n  }\n\n  return limiter;\n\n  function debounce(wait) {\n    return function (fn) {\n      return _.debounce(fn, wait);\n    };\n  }\n\n  function throttle(wait) {\n    return function (fn) {\n      return _.throttle(fn, wait);\n    };\n  }\n}\n\nfunction callbackToDeferred(fn) {\n  return function (o) {// var deferred = $.Deferred();\n    // fn(o, onSuccess, onError);\n    // return deferred;\n    // function onSuccess(resp) {\n    //   // defer in case fn is synchronous, otherwise done\n    //   // and always handlers will be attached after the resolution\n    //   _.defer(function() { deferred.resolve(resp); });\n    // }\n    // function onError(err) {\n    //   // defer in case fn is synchronous, otherwise done\n    //   // and always handlers will be attached after the resolution\n    //   _.defer(function() { deferred.reject(err); });\n    // }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}