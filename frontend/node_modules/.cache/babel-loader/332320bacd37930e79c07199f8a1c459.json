{"ast":null,"code":"var _ = require('./utils');\n\nvar Promise = require('es6-promise').Promise;\n\nvar Remote = require('./remote');\n\nvar Prefetch = require('./prefetch');\n\nvar tokenizers = require('./tokenizers');\n\nvar oParser = require('./options_parser');\n\nvar SearchIndex = require('./search_index');\n\nvar Transport = require('./transport');\n\nfunction Bloodhound(o) {\n  o = oParser(o);\n  this.sorter = o.sorter;\n  this.identify = o.identify;\n  this.sufficient = o.sufficient;\n  this.local = o.local;\n  this.remote = o.remote ? new Remote(o.remote) : null;\n  this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null; // the backing data structure used for fast pattern matching\n\n  this.index = new SearchIndex({\n    identify: this.identify,\n    datumTokenizer: o.datumTokenizer,\n    queryTokenizer: o.queryTokenizer\n  }); // hold off on intialization if the intialize option was explicitly false\n\n  o.initialize !== false && this.initialize();\n}\n\nBloodhound.tokenizers = tokenizers;\n\n_.mixin(Bloodhound.prototype, {\n  // ### super secret stuff used for integration with jquery plugin\n  __ttAdapter: function ttAdapter() {\n    var that = this;\n    return this.remote ? withAsync : withoutAsync;\n\n    function withAsync(query, sync, async) {\n      return that.search(query, sync, async);\n    }\n\n    function withoutAsync(query, sync) {\n      return that.search(query, sync);\n    }\n  },\n  _loadPrefetch: function loadPrefetch() {\n    var that = this,\n        promise,\n        serialized;\n\n    if (!this.prefetch) {\n      return new Promise(function (resolve, reject) {\n        resolve();\n      });\n    } else if (serialized = this.prefetch.fromCache()) {\n      this.index.bootstrap(serialized);\n      return new Promise(function (resolve, reject) {\n        resolve();\n      });\n    } else {\n      // this.prefetch.fromNetwork(done);\n      return new Promise(function (resolve, reject) {\n        // todo: promise\n        that.prefetch.fromNetwork(function (err, data) {\n          if (err) return reject(err);\n\n          try {\n            that.add(data);\n            that.prefetch.store(that.index.serialize());\n            resolve();\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n    }\n  },\n  _initialize: function () {\n    var that = this,\n        deferred; // in case this is a reinitialization, clear previous data\n\n    this.clear();\n\n    (this.initPromise = this._loadPrefetch()).then(addLocalToIndex); // local must be added to index after prefetch\n\n\n    return this.initPromise;\n\n    function addLocalToIndex() {\n      that.add(that.local);\n    }\n  },\n  // ### public\n  initialize: function (force) {\n    return !this.initPromise || force ? this._initialize() : this.initPromise;\n  },\n  // TODO: before initialize what happens?\n  add: function (data) {\n    this.index.add(data);\n    return this;\n  },\n  get: function (ids) {\n    ids = _.isArray(ids) ? ids : [].slice.call(arguments);\n    return this.index.get(ids);\n  },\n  search: function (query, sync, async) {\n    var that = this,\n        local;\n    local = this.sorter(this.index.search(query)); // return a copy to guarantee no changes within this scope\n    // as this array will get used when processing the remote results\n\n    sync(this.remote ? local.slice() : local);\n\n    if (this.remote && local.length < this.sufficient) {\n      this.remote.get(query, processRemote);\n    } else if (this.remote) {\n      // #149: prevents outdated rate-limited requests from being sent\n      this.remote.cancelLastRequest();\n    }\n\n    return this;\n\n    function processRemote(remote) {\n      var nonDuplicates = []; // exclude duplicates\n\n      _.each(remote, function (r) {\n        !_.some(local, function (l) {\n          return that.identify(r) === that.identify(l);\n        }) && nonDuplicates.push(r);\n      });\n\n      async && async(nonDuplicates);\n    }\n  },\n  all: function () {\n    return this.index.all();\n  },\n  clear: function () {\n    this.index.reset();\n    return this;\n  },\n  clearPrefetchCache: function () {\n    this.prefetch && this.prefetch.clear();\n    return this;\n  },\n  clearRemoteCache: function () {\n    Transport.resetCache();\n    return this;\n  },\n  // DEPRECATED: will be removed in v1\n  ttAdapter: function () {\n    return this.__ttAdapter();\n  }\n});\n\nmodule.exports = Bloodhound;","map":null,"metadata":{},"sourceType":"script"}