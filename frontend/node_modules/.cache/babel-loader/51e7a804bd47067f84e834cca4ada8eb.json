{"ast":null,"code":"var LruCache = require('./lru_cache');\n\nvar _ = require('./utils');\n\nvar pendingRequestsCount = 0;\nvar pendingRequests = {};\nvar maxPendingRequests = 6;\nvar sharedCache = new LruCache(10);\n\nfunction Transport(o) {\n  o = o || {};\n  this.cancelled = false;\n  this.lastReq = null;\n  this._send = o.transport;\n  this._get = o.limiter ? o.limiter(this._get) : this._get;\n  this._cache = o.cache === false ? new LruCache(0) : sharedCache;\n}\n\nTransport.setMaxPendingRequests = function setMaxPendingRequests(num) {\n  maxPendingRequests = num;\n};\n\nTransport.resetCache = function resetCache() {\n  sharedCache.reset();\n};\n\n_.mixin(Transport.prototype, {\n  _fingerprint: function (o) {\n    o = o || {};\n    return o.url + o.type + JSON.stringify(o.data || {});\n  },\n  _get: function (o, cb) {\n    var that = this,\n        fingerprint,\n        jqXhr;\n    fingerprint = this._fingerprint(o); // #149: don't make a network request if there has been a cancellation\n    // or if the url doesn't match the last url Transport#get was invoked with\n\n    if (this.cancelled || fingerprint !== this.lastReq) {\n      return;\n    } // a request is already in progress, piggyback off of it\n\n\n    if (jqXhr = pendingRequests[fingerprint]) {\n      // jqXhr.done(done).fail(fail);\n      jqXhr.then(done, fail);\n    } // under the pending request threshold, so fire off a request\n    else if (pendingRequestsCount < maxPendingRequests) {\n        pendingRequestsCount++;\n        pendingRequests[fingerprint] = // this._send(o).done(done).fail(fail).always(always);\n        this._send(o).then(function (resp) {\n          done(resp);\n          always();\n        }, function () {\n          fail();\n          always();\n        });\n      } // at the pending request threshold, so hang out in the on deck circle\n      else {\n          this.onDeckRequestArgs = [].slice.call(arguments, 0);\n        }\n\n    function done(resp) {\n      cb(null, resp);\n\n      that._cache.set(fingerprint, resp);\n    }\n\n    function fail() {\n      cb(true);\n    }\n\n    function always() {\n      pendingRequestsCount--;\n      delete pendingRequests[fingerprint]; // ensures request is always made for the last query\n\n      if (that.onDeckRequestArgs) {\n        that._get.apply(that, that.onDeckRequestArgs);\n\n        that.onDeckRequestArgs = null;\n      }\n    }\n  },\n  get: function (o, cb) {\n    var resp, fingerprint;\n    cb = cb || _.noop;\n    o = _.isString(o) ? {\n      url: o\n    } : o || {};\n    fingerprint = this._fingerprint(o);\n    this.cancelled = false;\n    this.lastReq = fingerprint; // in-memory cache hit\n\n    if (resp = this._cache.get(fingerprint)) {\n      cb(null, resp);\n    } // go to network\n    else {\n        this._get(o, cb);\n      }\n  },\n  cancel: function () {\n    this.cancelled = true;\n  }\n});\n\nmodule.exports = Transport;","map":null,"metadata":{},"sourceType":"script"}