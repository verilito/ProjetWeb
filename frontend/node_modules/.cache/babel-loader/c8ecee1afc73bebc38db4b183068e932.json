{"ast":null,"code":"var _ = require('./utils');\n\nvar CHILDREN = 'c';\nvar IDS = 'i';\n\nfunction SearchIndex(o) {\n  o = o || {};\n\n  if (!o.datumTokenizer || !o.queryTokenizer) {\n    throw new Error('datumTokenizer and queryTokenizer are both required');\n  }\n\n  this.identify = o.identify || _.stringify;\n  this.datumTokenizer = o.datumTokenizer;\n  this.queryTokenizer = o.queryTokenizer;\n  this.reset();\n}\n\n_.mixin(SearchIndex.prototype, {\n  bootstrap: function (o) {\n    this.datums = o.datums;\n    this.trie = o.trie;\n  },\n  add: function (data) {\n    var that = this;\n    data = _.isArray(data) ? data : [data];\n\n    _.each(data, function (datum) {\n      var id, tokens;\n      that.datums[id = that.identify(datum)] = datum;\n      tokens = normalizeTokens(that.datumTokenizer(datum));\n\n      _.each(tokens, function (token) {\n        var node, chars, ch;\n        node = that.trie;\n        chars = token.split('');\n\n        while (ch = chars.shift()) {\n          node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());\n          node[IDS].push(id);\n        }\n      });\n    });\n  },\n  get: function (ids) {\n    var that = this;\n    return _.map(ids, function (id) {\n      return that.datums[id];\n    });\n  },\n  search: function (query) {\n    var that = this,\n        tokens,\n        matches;\n    tokens = normalizeTokens(this.queryTokenizer(query));\n\n    _.each(tokens, function (token) {\n      var node, chars, ch, ids; // previous tokens didn't share any matches\n\n      if (matches && matches.length === 0) {\n        return false;\n      }\n\n      node = that.trie;\n      chars = token.split('');\n\n      while (node && (ch = chars.shift())) {\n        node = node[CHILDREN][ch];\n      }\n\n      if (node && chars.length === 0) {\n        ids = node[IDS].slice(0);\n        matches = matches ? getIntersection(matches, ids) : ids;\n      } // break early if we find out there are no possible matches\n      else {\n          matches = [];\n          return false;\n        }\n    });\n\n    return matches ? _.map(unique(matches), function (id) {\n      return that.datums[id];\n    }) : [];\n  },\n  all: function () {\n    var values = [];\n\n    for (var key in this.datums) {\n      values.push(this.datums[key]);\n    }\n\n    return values;\n  },\n  reset: function () {\n    this.datums = {};\n    this.trie = newNode();\n  },\n  serialize: function serialize() {\n    return {\n      datums: this.datums,\n      trie: this.trie\n    };\n  }\n});\n\nfunction normalizeTokens(tokens) {\n  // filter out falsy tokens\n  tokens = _.filter(tokens, function (token) {\n    return !!token;\n  }); // normalize tokens\n\n  tokens = _.map(tokens, function (token) {\n    return token.toLowerCase();\n  });\n  return tokens;\n}\n\nfunction newNode() {\n  var node = {};\n  node[IDS] = [];\n  node[CHILDREN] = {};\n  return node;\n}\n\nfunction unique(array) {\n  var seen = {},\n      uniques = [];\n\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (!seen[array[i]]) {\n      seen[array[i]] = true;\n      uniques.push(array[i]);\n    }\n  }\n\n  return uniques;\n}\n\nfunction getIntersection(arrayA, arrayB) {\n  var ai = 0,\n      bi = 0,\n      intersection = [];\n  arrayA = arrayA.sort();\n  arrayB = arrayB.sort();\n  var lenArrayA = arrayA.length,\n      lenArrayB = arrayB.length;\n\n  while (ai < lenArrayA && bi < lenArrayB) {\n    if (arrayA[ai] < arrayB[bi]) {\n      ai++;\n    } else if (arrayA[ai] > arrayB[bi]) {\n      bi++;\n    } else {\n      intersection.push(arrayA[ai]);\n      ai++;\n      bi++;\n    }\n  }\n\n  return intersection;\n}\n\nmodule.exports = SearchIndex;","map":null,"metadata":{},"sourceType":"script"}